# 분할정복 알고리즘 (1)

## 학습목표

1. 분할정복 방법의 원리, 특징, 처리 단계 등을 이해하고 설명할 수 있다.
2. 이진 탐색의 원리, 동작, 성능, 특징을 이해하고 적용할 수 있다.
3. 퀵 정렬의 원리, 동작, 분할 함수, 성능, 특징을 이해하고 적용할 수 있다.

## 강의 필기 & 정리

### 1. 분할정복 방법의 원리

#### 분할정복 방법

순환적으로(recursively) 문제를 푸는 하향식(top-down)접근 방법
- 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할
- 분할된 작은 문제를 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식

특징
- 분할된 작은 문제는 원래 문제와 동일
  - 단, 입력 크기만 작아짐
- 분할된 작은 문제는 서로 독립적
  - 순환적 분할 및 결과 통합이 가능

#### 분할정복 방법의 처리 단계

각 순환 호출마다 세 단계의 처리 과정을 거침
- 분할: 주어진 문제를 여러 개의 작은 문제로 분할한다.
- 정복: 작은 문제를 순환적으로 분할. 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다.
- 결합: 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.(결합 단계가 없는 문제도 존재)

#### 적용 알고리즘의 종류 및 분할 과정
- 이진탐색
- 합병정렬
- 퀵 정렬
- 선택 문제

### 2. 이진 탐색

#### 개념과 원리
- 정렬된 상태의 입력 데이터에 대한 효과적인 탐색 방법
  - 오름차순으로 정렬되었다고 가정
- 탐색 방법
  - 배열의 가운데 원소 A[mid]와 탐색키 x를 비교
    1) 탐색키 == 가운데 원소 -> 탐색 성공(인덱스 mid 반환 후 종료)
    2) 탐색키 < 가운데 원소 -> 이진 탐색(원래 크기 1/2인 왼쪽 부분배열) 순환 호출
    3) 탐색키 > 가운데 원소 -> 이진 탐색(원래 크기 1/2인 오른쪽 부분배열) 순환 호출
  - 탐색을 반복할 떄마다 대상 원소의 개수가 1/2씩 감소
- 분할:
  - 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 분할
  - 탐색키와 가운데 원소가 같으면 가운데 원소의 배열 인덱스를 반환 및 종료
- 정복:
  - 탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출
  - 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출
- 결합:
  - 필요 없음

#### 알고리즘 - 순환 형태

```
BinarySearch(A[], Left, Right, x)
{
  if (Left > Right) return -1; // 탐색 실패
  Mid = Math.floor((Left + Right) / 2);
  if( x == A[Mid]) return Mid; // 탐색 성공 -> 인덱스 mid 반환
  else if ( x < A[Mid]>) BinarySearch(A, Left, Mid - 1, x); // 왼쪽 부분배열
  else BinarySearch(A, Mid+1, Right, x); // 오른쪽 부분 배열
}
```

#### 알고리즘 - 반복 형태

```
BinarySearch_Iteration(A[], n, x)
{
  Left = 0; Right = n - 1;
  while(Left <= Right) {
    Mid = Math.floor((Left + Right) / 2);
    if( x == A[Mid] ) return Mid;
    else if ( x < A[Mid] ) Right = Mid - 1;
    else Left = Mid + 1;
  }
  return -1;
}
```

#### 이진 탐색에서의 분할 및 비교 횟수
- 최대 분할 횟수: $k = \log_2{n}$
- 최대 비교 횟수: 최대 분할 횟수 + 1

#### 성능 분석

$
\begin{matrix}
T(n) &=& \text{입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합} \\
     &=& \text{맨 바깥 수준에서의 비교 횟수} + \text{순환 호출에서의 비교 횟수}
\end{matrix}
$

$T(n) = T(n/2) + O(1) \\ 
 T(1) = 1 \\ 
 T(n) = O(\log{n})$

#### 특징
- 입력 배열의 데이터가 정렬된 경우에 대해서만 적용 가능
- 삽입/삭제 연산은 부가적인 데이터 이동을 수반
  - 데이터의 정렬 상태 유지를 위해서 평균 n/2개의 데이터 이동이 발생
    - 삽입/삭제가 빈번한 응용에서는 부적합

### 3. 퀵 정렬

#### 개념과 원리

- 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
  - 오름차순으로 정렬한다고 가정

- 피벗 pivot
  - 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
    - 보통 주어진 배열의 첫 번쨰 원소로 지정

- 피벗이 제자리를 잡도록 하여 정렬하는 방식
  ```
  분할 전: #30 45 20 15  40 25 35 10
  분할 후:  25 10 20 15 #30 40 35 45
  ```
- 왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값

- 분할
  - 피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.
- 정복
  - 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.
- 결합
  - 필요 없음

#### 알고리즘 - 퀵 정렬
```
QuickSort (A[ ], n)
{ 
  if (n>1) {
    pivot = Partition(A[0..n-1], n); //두 부분배열로 분할
    QuickSort(A[0..pivot-1], pivot); //왼쪽 부분배열에 대한 순환 호출
    QuickSort(A[pivot+1..n-1], n-pivot-1); //오른쪽 부분배열에 대한 순환 호출
  }
}


int Partition (A[ ], n)
{ 
  Left = 1; Right = n-1;
  while ( Left < Right ) { //피벗 A[0]
  
    //피벗보다 큰 값의 위치를 찾음
    while ( Left < n && A[Left] < A[0] ) Left++; 
  
    //피벗보다 작은 값의 위치를 찾음
    while ( Right > 0 && A[Right] >= A[0] ) Right--;
  
    if ( Left < Right ) 교환(A[Left] ⇔ A[Right])
    else 교환(A[0] ⇔ A[Right])
  }
  return Right;
}
```

#### 성능 분석
- 분할 함수 Partition() 수행 시간
  - 피벗과의 비교 횟수 $\theta(n)$
- 퀵 정렬 QuickSort() 수행 시간
  - $\begin{matrix} T(n) &=& T(n - x) + T(x) + \theta(n) \\ T(1) &=& \theta(1) \end{matrix}$

#### 성능 분석 - 최악의 경우
- 극심한 불균형적 분할
  - 0:n-1, n-1:0 -> 피벗만 제자리를 잡고 나머지 모든 원소가 하나의 부분배열이 되는 경우
  - 피벗이 항상 부분배열의 최소값 또는 최대값이 되는 경우
  - 입력 데이터가 정렬된 경우 AND 피벗을 배열의 처음 원소를 정한 경우
  - $\begin{matrix} T(n) &=& T(n-1) + T(0) + \theta(n), T(0) = 0 \\ T(n) &=& T(n-1) + \theta(n) \\ T(n) &=& O(n^2) \end{matrix}$

#### 성능 분석 - 최선의 경우
- 배열이 항상 n/2 : n/2로 분할되는 경우
- 가장 균형적인 분할
  - 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
  - 피벗이 항상 부분배열의 중간값이 되는 경우
  - $\begin{matrix} T(n) &=& T(n/2) + T(n/2) + \theta(n), T(1) = 1 \\ T(n) &=& 2T(n/2) + \theta(n) \\ T(n) &=& O(n\log{n})\end{matrix}$

#### 성능 분석 - 평균적인 경우
- 부분배열의 모든 분할 비율에 따른 수행 시간의 평균
  - 피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능
  - $T(1) = T(0) = 0$
  - $T(n) = \frac{1}{n}\sum_{i=1}^n (T(i-1) + T(n - 1)) + \theta(n), {n}\ge{2}$
  - $T(n) = O(n\log{n})$

#### 특징
- 최선/평균 수행 시간 -> $O(n\log{n})$
- 최악 수행 시간 -> $O(n^2)$
  - 피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음
    - 배열에서 임의의 값을 선택한 후, 배열의 처음 원소와 서로 교환한 후 정렬 수행

## 정리하기

1. 분할정복 방법의 원리
   1) 순환적으로 문제를 푸는 하향식 접근 방법 -> 분할 - 정복 - 결합
2. 이진 탐색
   1) 정렬된 상태의 데이터를 절반씩 줄여가면서 원하는 값을 찾는 방법
      1) <img src="https://latex.codecogs.com/svg.latex?T(n) = T(n/2) + \theta(1), T(1) = \theta(1), \theta(\log{n})"/>
      2) 정렬된 데이터에 대해서만 적용 가능, 삽입/삭제가 빈번한 응용에는 부적합
3. 퀵 정렬
   1) 왼쪽 부분배열의 모든 값 < 피벗 오른쪽 부분배열의 모든 값
   2) 분할 함수 Partition() -> 주어진 배열을 두 부분배열로 나누는 함수
   3) 성능
      1) 최악의 경우: T(n)=T(n-1)+Θ(n), T(1)=Θ(1) → O(n2)
      2) 최선의 경우: T(n)=2T(n/2)+Θ(n), T(1)=Θ(1) → O(nlogn)
      3) 평균적인 경우: O(nlogn)
4. 특징: 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 높음

